

[
  
  
    
    
      {
        "title": "Talk about documentations (2022-10-20)",
        "excerpt": "Topics\n",
        "content": "Topics\n\n\n  文档 site 的布局与样式\n  \n    图形库的名字\n\n    \n      中文 “仓库图形库”\n      英文 “WarehouseGUI” ？\n    \n  \n  \n    讨论一下文档的作用，从两个视角\n\n    \n      作者\n      阅读者\n    \n  \n  \n    idea：从文档出发驱动实现\n  \n  图形库的构建打包：umd + d\n  \n    拿两个写好的文档一起具体讨论下：\n\n    \n      排版\n      能否读懂\n      能否通过文档了解到作者的设计\n      有什么好的意见/建议\n    \n  \n  \n    内容的两个部分：\n\n    \n      api - 注释\n      overview\n    \n  \n\n\n会议记录\n",
        "url": "/blog/2023/02/12/talk-how-to-write-doc.html"
      },
    
  
  
  
  {
    "title": "About",
    "excerpt": "\n",
    "content": "What is Wik?\n\nWik is a JavaScript Library for big-scale warehouse visualization. Both 2D and 3D are supported. With Wik, you would visualize the warehouse very easily.\n\nWho needs Wik?\n\n…\n\nWhat can Wik help you?\n\n…\n",
    "url": "/about.html"
  },
  
  {
    "title": "Animations",
    "excerpt": "\n",
    "content": "动画是 layer 的状态从 A 变迁到 B 的过程连续性呈现。\n\nCSS 中的 animation 被定义为几个关键帧加上对元素的动画设定，\n\n@keyframes slide-in {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n.div {\n  animation: slide-in 0.3s linear 3ms;\n}\n\n\nWik 与之类似，我们将一个动画以 class 的方式描述出来，然后交由 AnimationManager 来调度，AnimationManager 调度的基础是 requestAnimationFrame。\n\n基类\n\nAnimation 基类在 2d/animation 下，它接收一个动画主体 WithAnimate 和一个 value，value 是主体将要达到的状态。Animation 包含了动画持续时长 timing 以及 delta 或者切片数 N 的计算逻辑，不管怎样的形式的状态描述，我们总有办法将变化计算为这两个数字。\n\n动画调度\n\nAnimationManager 并不神秘，在一个循环函数中，它遍历添加进来的动画请求列表，调用它们的 run 方法，直到 timeout，将主体置于终态。这个循环函数由 requestAnimationFrame 调用，每次循环结束，我们会清理掉过期的项目。如果，动画请求数为 0，循环就会停止。\n\nconst loop = () =&gt; {\n  requestAnimationFrame(loop);\n\n  for (const animation of animtions) {\n    if (animation.timeout()) continue;\n    animation.run();\n  }\n\n  clean(animations);\n};\n\n\n自定义动画\n\n定义一个动画，就是通过动画基类扩展实现的，主要实现其三个方法：\n\n\n  start 初始化 - 一般计算出 N 或者 duration 和 delta\n  run 过程计算\n  final 终态设置\n\n\nclass OpacityAnimation extends WikAnimation {\n  start() {\n    this.N = 100;\n  }\n\n  run(elapse: number) {\n    // set opacity = ...\n  }\n\n  final() {\n    // set opacity = value\n  }\n}\n\n\n然后，执行 OpacityAnimation ，我们使用 appendAnimation 这个函数，\n\nappendAnimation.call(layer, new OpacityAnimation(layer, 0));\n\n\n\n注意，其中 layer 必须是 WithAnimate\n\n\nWik 提供的动画\n\n\n  RotationAnimation\n  TranslationAnimation\n  BezierTranslationAnimation\n\n",
    "url": "/guides/animation.html"
  },
  
  {
    "title": "APIs",
    "excerpt": "\n",
    "content": "API documentaion is generated by Typedoc, it’s another page standalone.\nYou can click! to get there.\n",
    "url": "/api.html"
  },
  
  {
    "title": "Dependency Injection",
    "excerpt": "\n",
    "content": "wiki 上对 DI 的定义是，\n\n\n  In software engineering, dependency injection is a design pattern in which an object or function receives other objects or functions that it depends on. A form of inversion of control, dependency injection aims to separate the concerns of constructing objects and using them, leading to loosely coupled programs\n\n\nhttps://en.wikipedia.org/wiki/Dependency_injection\n\n它是一个设计模式，是控制反转的一种形式。它的目的是分离关注点，分离的是“构建”和“使用”，以达到解耦的效果。\n\n百科同时也给出了这种设计模式的好处，\n\nhttps://en.wikipedia.org/wiki/Dependency_injection#Advantages\n\nWik 自己实现了依赖注入，原理比较简单，后边会补充文档。这里仅对如何使用做出说明。\n\n特性\n\n\n  注入的层级性\n  提供策略：构造、工厂、值\n  注入策略：构造参数、属性\n  注入的继承性\n\n\n注入的层级性\n\n受 Angular 启发，Wik 支持了此特性，目的是为了支持多库区功能。\n\n层级针对的是服务容器（简称“容器”），即容器具有层级性，它形成了一个树结构，我们将容器封装进一个叫 Injector 的实现类中，因此可以说容器就是 Injector 实例。要将一个被注入目标类声明为一个容器，需要使用到 provides 装饰，\n\n@injectable()\nclass MyLogger {}\n\n@provides({\n  [Symbol.for('ILogger')]: MyLogger,\n})\nclass Warehouse {\n  @inject(Symbol.for('ILogger'))\n  logger: MyLogger;\n}\n\n\n这样，不同的 Warehouse 实例就会拥有自己的 logger，\n\nconst warehouse1 = rootInjector.$new(Warehouse);\nconst warehouse2 = rootInjector.$new(Warehouse);\n\nconsole.log(warehouse1.logger === warehouse2.logger); // false\n\n\n既是树，就会存在一个根节点，这里是 rootInjector。 rootInjector 的服务通过 configProviders 函数声明，\n\nconfigProviders('root', {\n  [Interfaces.IImageManager]: ImageManager,\n  [Interfaces.IGlobalConstManager]: GlobalConstManager,\n  [Interfaces.ILogger]: { useFactory: () =&gt; console },\n});\n\n\n层级关系通过 Injector 的 $new 方法建立，服务的查询通过 parent 字段回退，直到根节点。目前只有 $new 方法才会建立容器，属性注入直接继承当前绑定对象的容器，而不是创建新的，即使你使用了 provides 装饰。这是一个局限，使用的时候需要注意。\n\n现在，我们修改 MyLogger，向其注入 ImageManager，\n\n@injectable()\nclass MyLogger {\n  @inject(Interfaces.IImageManager)\n  imageMgr: IImageManager;\n}\n\n\n那么， warehouse1.logger.imageMgr 和 warehouse2.logger.imageMgr 将会是同一个，它们都来自根节点。\n\n如果需要隔离服务，可以使用 provides 装饰器向 Warehouse 提供这个服务，\n\n@provides({\n  [Symbol.for('ILogger')]: MyLogger,\n  [Interfaces.IImageManager]: ImageManager,\n})\nclass Warehouse {\n  @inject(Interfaces.ILogger)\n  logger: MyLogger;\n}\n\n\n这样，warehouse1.logger.imageMgr 和 warehouse2.logger.imageMgr 是独立的实例。\n\n根据我们的查询规则，logger 作为 Warehouse 子节点，其本身并不创建容器，而是直接使用 Warehouse 的容器，因此首先在 Warehouse 的容器中查询 IImageManager 这个服务。\n\n提供策略：构造、工厂、值\n\n最常见的提供策略是 new 关键字，以上面的 MyLogger 为例，你需要将 MyLogger 被标注为 injectable。这是必需的，否则我们不会为你构建服务。\n\n@injectable()\nclass MyLogger {}\n\n@provides({\n  [Interfaces.ILogger]: MyLogger,\n})\nclass Warehouse {}\n\n\n也可以使用工厂策略，当然这脱离了注入系统，\n\n@provides([\n  {\n    provide: Interfaces.ILogger,\n    useFactory: () =&gt; new MyLogger(),\n  },\n])\nclass Warehouse {}\n\n\n你还可以使用常量提供，同样这样的策略也脱离了注入系统，\n\n@provides([\n  {\n    provide: Interfaces.ILogger,\n    useValue: new MyLogger(),\n  },\n])\nclass Warehouse {}\n\n\n注入策略：构造参数、属性\n\n注入策略目前支持构造参数、属性两种。使用参数注入的时候，你需要在 class 层面添加注解，\n\n@inject(Interfaces.ILogger)\nclass Warehouse {\n  constructor(private logger: ILogger);\n}\n\n\n使用属性注入的时候，你需要对属性添加注解，\n\nclass Warehouse {\n  @inject(Interfaces.ILogger)\n  logger: ILogger;\n}\n\n\n注入的继承性\n\n因为类本身具有继承性，Wik 也对注入做了继承性处理，\n\nabstract class Warehouse {\n  @inject(Interfaces.ILogger)\n  logger: ILogger;\n}\n\nclass EssWarehouse extends Warehouse {}\n\nconst warehouse = rootInjector.$new(EssWarehouse);\n\nconsole.log(!!warehouse.logger); // true\n\n",
    "url": "/guides/di.html"
  },
  
  {
    "title": "Components",
    "excerpt": "\n",
    "content": "在 dom 目录下，我们提供了几个 React 组件和 Hooks，它们和 leaflet layer、Wik model、ess 业务结合紧密，目的是给予用户快速构建 UI 的能力。\n\n要查阅这些组件、Hooks 的具体 API，你可前往 API 页面并定位至相关模块，此文档主要对它们的组合使用加以说明。\n\n\n  Scene\n  Warehouse\n  ViewSet\n  View\n  useEvented\n  useLeafletEvented\n  useSelection\n  useMultipleSelection\n\n\nScene\n\nScene 为你创建了一个 Map 以及用于 UI 呈现的 element，并将由外界输入的 warehouse 与之关联起来，从而让用户只关心 Warehouse 的 API 即可。\n\n除了 Scene 组件本身，它还额外提供了以下组件：\n\n\n  Layout\n  SelectShell\n  MultipleSelectShell\n\n\nLayout 用于对视窗快速布局，默认地图主视区占据剩余空间。\n\nSelectShell 用于响应元素的点击选择，当用户选择了一个元素的时候，其包裹的元素会被渲染，并且通过 model 属性注入当前选择的元素。\n\nconst Detail = (props: LayerSelectProps) =&gt; {\n  return &lt;div&gt;you've selected {props.model.layerId}&lt;/div&gt;;\n};\n\nconst Main = () =&gt; {\n  return (\n    &lt;Scene.SelectShell&gt;\n      &lt;Detail /&gt;\n    &lt;/Scene.SelectShell&gt;\n  );\n};\n\n\nMultipleSelectShell 用于响应多选，当用户框选或者连续点选了一些元素，其包裹的组件会被渲染，用法与 SelectShell 类似。\n\nWarehouse\n\nWarehouse 为用户提供一个上下文 __warehouse_context__，它作为 ViewSet 组件的父组件。它并不为用户创建 warehouse 实例，因此 warehouse 需要用户提供，默认 warehouse 从 Scene 组件传递下来。Warehouse 组件的一个必要属性是 modelViewMapping，它定义了模型到视图的映射，为视图创建提供策略。\n\nconst modelViewMapping = {\n  bot: (m: any, w: IWarehouse) =&gt; w.injector.$new(Bot2),\n  dot: (m: any, w: IWarehouse) =&gt; new Dot([m.py, m.px]),\n};\n\n\nViewSet\n\n为了查询效率和更好的抽象以及 leaflet 意义上的图层管理， 图形库对其所管理的元素都进行了分类和分层，其载体是 LayerList。ViewSet 组件就用于管理这些 LayerList，包括创建、与业务模型列表绑定。ViewSet 帮助你完成了元素的创建、添加和移除，至于元素自身的变化，需要“模型驱动”机制。\n\nView\n\nView 不会向用户开放。ViewSet 内部会用到它，这里不作说明。\n\nHooks\n\nuseEvented 适用于扩展了 EventEmitter 的子类，用于响应一个或者多个事件，响应的逻辑是刷新组件；\n\n与 useEvented 类似，只不过 useLeafletEvented 适用于 leaflet 的 L.Evented。\n\nuseSelection 收集需要响应点击选择的组件，以在事件发生时刷新组件；\n\n与 useSelection 类似，useMultipleSelection 用于响应多选事件，并返回选中的元素。\n\n注意，useSelection 和 useMultipleSelection 并不能独立使用，你需要将 SelectionContext 挂载到 React 树上。\n",
    "url": "/guides/dom.html"
  },
  
  {
    "title": "Guides",
    "excerpt": "\n",
    "content": "\n\n\n    Animations\n\n    Dependency Injection\n\n    Components\n\n    Mixins\n\n    The relations of Models &amp; Views\n\n    Behaviors &amp; Modes\n\n    Introduction to React-SVGOverlay\n\n    Introducation to Reactive Layer\n\n    Undo &amp; Redo\n\n    Why do we need this library?\n\n\n",
    "url": "/guides.html"
  },
  
  {
    "title": "Mixins",
    "excerpt": "\n",
    "content": "以下是 wiki 上的定义：\n\n\n  Mixins are a language concept that allows a programmer to inject some code into a class. Mixin programming is a style of software development, in which units of functionality are created in a class and then mixed in with other classes.\n\n\nhttps://en.wikipedia.org/wiki/Mixin\n\n混入能带来较继承更多的好处，维基上也有列出：\n\nhttps://en.wikipedia.org/wiki/Mixin#Advantages\n\n在 JavaScript 中，常见的混入方式为修改原型，它比较容易实现，但是存在一定的风险。Justin Fagnani 在博客 “Real” Mixins with JavaScript Classes 中提出了一种更安全的混入机制，它的基础是类的继承。\n\nWik 对这两种方式均有采用，基本的原则是，简单的混入使用修改原型方式，否则使用继承的方式。\n\n修改原型\n\n注意，这种方式只混入类的方法成员，这样可以简化问题。因为若要同时混入属性成员，就需要调用构造函数，这会增加代码的复杂度。\n\n一个例子是mixins/Emitter.ts，首先定义一个类，建议类名以Mix结尾，\n\nexport abstract class EmitterMix implements WithParent&lt;EmitterMix&gt; {\n  __super__: any;\n  $$parent: EmitterMix;\n\n  static event: WikEvent = null;\n\n  noEmit = false;\n\n  emit(event: string, payload: any) {\n    // ...\n  }\n}\n\n\n然后定义 TS 类型声明，这可以让混入更安全，同时也能带来 IDE 的自动完成和建议提示等好处，\n\nexport interface WithEmitter&lt;E extends string&gt; {\n  /**\n   * set it True, the follow emit will be ignore and then set it False.\n   */\n  noEmit: boolean;\n  emit&lt;T extends EventNames&lt;E&gt;&gt;(event: T, payload?: AnyObject): boolean;\n}\n\n\n最后，使用这个 Mix，你可以使用内部提供的 mixin 装饰器，这样更直观，紧接着，你需要扩展混入目标类的类型，\n\n@mixin(EmitterMix)\nclass Base {}\n\ninterface Base extends WithEmitter&lt;string&gt; {}\n\n\n显然，EmitterMix 是有一个上下文的，这里是 EventEmitter3，它来自开源世界。所以，它的耦合性非常强，需要以下四个方面的配合：\n\n\n  混入类\n  混入类上下文\n  混入类的类型声明\n  目标类\n\n\n继承\n\n这种方式下，一个 mixin 被定义为：\n\n\n  A mixin is an abstract subclass\n\n\n即，一个抽象的子类。具体来说，mixin 是一个工厂函数：\n\ntype Mixin&lt;B extends object, M&gt; = (b: Constructor&lt;B&gt;) =&gt; Constructor&lt;B &amp; M&gt;;\n\n\n它接收一个类（JS 中当然就是一个构造函数），返回一个类。实现上，接收的这个类是父类，而返回的类由此继承得到。\n\n一个例子，也是目前唯一的例子，是mixins/ReactiveLayer.mixin.ts，\n\n首先，定义混入类的声明，建议在一个独立的文件中编写：\n\ninterface ReactiveLayer {\n  position: L.LatLng;\n  translate(lat: number, lng: number): void;\n}\n\n\n然后，实现对应的 Mix，也是建议独立文件编写，同时以追加mixin后缀作为文件名，实现类的类名以Mixin结尾，以表示它是ReactiveLayer的混入实现：\n\nfunction ReactiveLayerMixin(B: Constructor&lt;L.Layer&gt;): Constructor&lt;L.Layer &amp; ReactiveLayer&gt; {\n  return class extends B implements ReactiveLayer {\n    position: L.LatLng = null;\n\n    translate(lat: number, lng: number) {}\n  };\n}\n\n\n最后，使用它，拿2d/basic/Circle.class.ts为例，\n\nclass Circle extends mix(L.Circle).with&lt;L.Circle, ReactiveLayer&gt;(ReactiveLayerMixin) {}\n\n\n其中mix是内部提供的函数，mix接收的是目标混入类，ReactiveLayerMixin是混入类，最后 Circle 是完成了混入逻辑的类。这样在使用 Circle 的时候就可以应用 ReactiveLayer 提供的增强特性：\n\nconst circle = new Circle([0, 0]);\n\ncircle.translate(1000, 6000);\n\n\nMIX 函数\n\nmix 的实现比较简单，它本身的逻辑仅仅是切换混入上下文上绑定的目标混入类，\n\nconst context = { b: null, with: _with };\n\nfunction mix(b) {\n  context.b = b;\n  return context;\n}\n\n\n实际起作用的逻辑在 _with 函数中，\n\nfunction _with(...mixins: Mixin[]) {\n  return mixins.reduce((c, mixin) =&gt; {\n    return mixin(c);\n  }, this.b);\n}\n\n\n它使用了 reduce 函数对上下文中的 b 构造函数进行混入，返回的是最终混入了 mixins 的构造函数，其中构造函数也可以叫做“类”\n\n这样的实现方式不过是为了使代码更可读。\n\n处理类型\n\n拿 ReactiveLayer 来说，ReactiveLayerMixin 的混入目标类是 L.Layer 及其全部子类。实现 ReactiveLayerMixin 的时候，我们绑定是 L.Layer，但是使用的时候，可能是 L.Layer 的子类。如何兼容这些情况呢？可以采取的办法是函数重载。事实上，我们需要枚举出全部的子类，\n\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.Layer&gt;,\n): Constructor&lt;L.Layer &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(Base: Constructor&lt;L.Path&gt;): Constructor&lt;L.Path &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.Polyline&gt;,\n): Constructor&lt;L.Polyline &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.Polygon&gt;,\n): Constructor&lt;L.Polygon &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.Rectangle&gt;,\n): Constructor&lt;L.Rectangle &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.Circle&gt;,\n): Constructor&lt;L.Circle &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.CircleMarker&gt;,\n): Constructor&lt;L.CircleMarker &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.Marker&gt;,\n): Constructor&lt;L.Marker &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.SVGOverlay&gt;,\n): Constructor&lt;L.SVGOverlay &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.ImageOverlay&gt;,\n): Constructor&lt;L.ImageOverlay &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.DivOverlay&gt;,\n): Constructor&lt;L.DivOverlay &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.VideoOverlay&gt;,\n): Constructor&lt;L.VideoOverlay &amp; ReactiveLayer&gt;;\nexport function ReactiveLayerMixin(\n  Base: Constructor&lt;L.Layer&gt;,\n): Constructor&lt;L.Layer &amp; ReactiveLayer&gt;;\n\n\n只有这样，TS 类型系统才会在用户使用混入的时候适配到正确的目标类，从而用户可以在继承类中访问到具体的成员。\n\n总结\n\n\n  简单逻辑混入的时候，你可以采用原型修改的办法，但是需要四个方面的协调配合\n  复杂的混入，使用继承的方式更好，因为继承更不容易出错，而且你将获得诸多好处\n  实现一个继承式混入，你需要编写一个接口，接着枚举出全部的可混入的目标类以重载混入函数\n\n",
    "url": "/guides/mixins.html"
  },
  
  {
    "title": "The relations of Models & Views",
    "excerpt": "\n",
    "content": "概览\n\n业务模型，简称模型，它们持有全部的状态，并且拥有对状态做出变更的能力，最后以事件的方式告诉外界。\n\n模型是看不见的，可视化要做的事情时将之以几何形状呈现在用户面前，而模型的变更也需要通过变更图形来让用户感知到。\n\n视图也是一种模型，它连接的是数据对象和 GPU。但是视图只与显示相关，并无任何业务性质，大部分的可视化项目严重地涉及企业的业务。那么，要将公司的业务可视化，就需要连接业务模型和视图模型。\n\n存在一种选择，将业务对象定义在视图模型上，这是可行的。但是它存在的缺陷在于，业务与视图是强绑定关系，因此无法平滑地切换视图。比如，要显示一个机器人，我们会使用 Leaflet 的 SVGOverlay 组件，因其具有丰富的细节。而 SVGOverlay 是性能瓶颈极低，为了满足大量机器人的显示要求，我们不得不回退到 Circle 方案。\n\n问：要从 SVGOverlay 切换至 Circle，需要做哪些事？\n\n当然，首先需要定义 Circle 的显示样式，然后将同样的业务逻辑复制过来。\n\n显然，复制是不被允许的！\n\n因此，将业务从显示分离出来是必要的，于是就有了一套业务模型和若干套视图模型。这样分离之后，我们可以很平滑的将显示从 2D 切换到 3D。\n\n这并不是没有代价的，\n\n\n  我们需要定义一套视图接口层以抹平各种视图之间的 API 差异\n  视图更新必须由业务模型出发\n\n\nWik 已经梳理好了一套标准流程，严格沿着这套流程实施你的代码，就可以得到意想不到的好处。现在，大概展示一下如何依流程完成一个简单的例子，分为以下几步：\n\n\n  定义业务模型\n  定义视图接口\n  定义两个视图模型（为了展示切换的平滑）\n  关联业务模型与视图\n\n\n这里，我们以机器人为例。\n\n定义业务模型\n\n模型必须由 Base 扩展出来，其中 @effect(KuboBotEffect.translate) 的意思是业务模型的这个方法被调用之后，对应的视图也需要调用对应的方法，以保持模型和视图的一致，\n\nimport { Base } from 'wik/model';\n\nenum KubotEffect {\n  translate = 'Translate',\n}\n\nclass Kubot extends Base&lt;KubotEffect&gt; {\n  px: number = 0;\n  py: number = 0;\n\n  @effect(KubotEffect.translate)\n  setPosition(x: number, y: number) {\n    this.px = x;\n    this.py = y;\n  }\n}\n\n\n定义视图接口\n\nimport { View } from 'wik/model';\n\ninterface KubotView extends View&lt;Kubot, KubotEffect&gt; {\n  whenTranslate(): void;\n}\n\n\n定义两个视图\n\nimport { Circle, SVGOverlay } from 'leaflet';\n\nclass Kubot1 extends Circle implements KubotView {\n  model: Kubot;\n\n  whenTranslate() {\n    const { px, py } = this.model;\n    this.setLatLng([py, px]);\n  }\n\n  whenInit() {\n    const { px, py } = this.model;\n    this.setLatLng([py, px]);\n  }\n}\n\nclass Kubot2 extends SVGOverlay implements KubotView {\n  model: Kubot;\n\n  private getBounds() {\n    // computes bounds from this.model\n    throw new Error('not implemented');\n  }\n\n  whenTranslate() {\n    this.setBounds(this.getBounds());\n  }\n\n  whenInit() {\n    this.setBounds(this.getBounds());\n  }\n}\n\n\n调用\n\n业务模型：\n\nconst bots = new List(hrModel.Robot, []);\n\n\n视图模型：\n\nconst warehouse = rootInjector.$new(Warehouse);\n\n\n连接业务模型和视图模型：\n\nconst modelViewMapping = {\n  circle: (m) =&gt; new Kubot1(),\n  overlay: (m) =&gt; new Kubot2(),\n};\n\n\n呈现：\n\n// presentation\nconst UI = () =&gt; {\n  return (\n    &lt;Scene warehouse={warehouse}&gt;\n      &lt;Warehouse modelViewMapping={modelViewMapping}&gt;\n        &lt;ViewSet model={bots} type=\"circle\" /&gt;\n        &lt;ViewSet model={bots} type=\"overlay\" /&gt;\n      &lt;/Warehouse&gt;\n    &lt;/Scene&gt;\n  );\n};\n\n",
    "url": "/guides/model-view.html"
  },
  
  {
    "title": "Behaviors & Modes",
    "excerpt": "\n",
    "content": "概览\n\n行为其实是应用对 leaflet 各种类型的事件的响应，主要有两类：\n\n\n  鼠标事件\n  键盘事件\n\n\n模式定义为一些行为的集合，比如在“只读”模式下，元素被点击后不会有任何效果；而在“编辑”模式下，元素会被选中并且弹出缩放和旋转按钮。\n\n将行为抽离，由模式收集起来，最后注册到系统中，这样的做法利于代码的管理，同时应用变得可扩展。\n\n行为\n\nWik 的行为可分为两类，一类是针对元素(item)的，另一类是针对地图画布(map)的。它们都会对应到“行为”的某个方法上，\n\n\n  \n    \n      type\n      event\n      callback\n    \n  \n  \n    \n      item\n      click\n      onClick\n    \n    \n      item\n      dblclick\n      onDblClick\n    \n    \n      item\n      mousedown\n      onPress\n    \n    \n      item\n      mouseover\n      onHover\n    \n    \n      item\n      mouseout\n      onUnHover\n    \n    \n      item\n      contextmenu\n      onContextMenu\n    \n    \n      map\n      click\n      onNoopClick\n    \n    \n      map\n      mousedown\n      onMouseDown\n    \n    \n      map\n      mousemove\n      onMouseMove\n    \n    \n      map\n      mouseup\n      onMouseUp\n    \n  \n\n\n我们对行为的接口声明是这样的：\n\ninterface IBehavior {\n  onLoad(): void;\n  onUnload(): void;\n\n  onHover(obj: GraphicObject, evt: unknown): void;\n  onUnHover(obj: GraphicObject, evt: unknown): void;\n  onClick(obj: GraphicObject, evt: unknown): void;\n  onDblClick(obj: GraphicObject, evt: unknown): void;\n  onPress(obj: GraphicObject, evt: unknown): void;\n  onContextMenu(obj: GraphicObject, evt: unknown): void;\n\n  onMouseDown(evt: unknown): void;\n  onMouseMove(evt: unknown): void;\n  onMouseUp(evt: unknown): void;\n  onNoopClick(evt: unknown): void;\n}\n\n\n模式\n\n模式是行为的集合，如果一个系统注册了多个模式，那么当前只能有一个模式生效，\n\ninterface IMode {\n  name: string;\n  behaviors: IBehavior[];\n  modeMgr: IModeManager;\n  load(): void;\n  unload(): void;\n  onLoad(): void;\n  onUnload(): void;\n}\n\n\n在 Warehouse 中使用模式\n\nIModeManager 用于管理模式，其 apply 方法意为调用当前模式下全部行为的指定回调函数，每一个 Warehouse 实例都会注入一个独立的 modeManager，Warehouse 会监听 map 的事件，以调用 modeManager 的 apply 方法作为响应，\n\ninterface IModeManager {\n  apply(callback: BehaviorCallback, ...args: any[]): void;\n}\n\n// under the warehouse context.\nthis.map.on('mousedown', (e) =&gt; {\n  this.modeManager.apply('onMouseDown', e);\n});\n\n\n可以使用 IModeManager.create 快速创建一个模式，\n\ninterface IModeManager {\n  create(name: string, ...behaviors: IBehavior[]): void;\n}\n\n\n\n注意，模式的名字非常关键，不要重复。\n\n",
    "url": "/guides/modes.html"
  },
  
  {
    "title": "Quick",
    "excerpt": "\n",
    "content": "Installation\n\nYou can use yarn or npm,\n\n\nyarn add @zxh19890103/wik\n\n# or npm\n\nnpm install @zxh19890103/wik\n\n\n\nCode &amp; Run it.\n\nIn your project, define your Warehouse class.\n\nimport { wik, wikui } from '@zxh19890103/wik';\n\n@wik.inject(...)\nclass MyWarehouse extends wikui.WikWarehouse {\n  layout() {\n    // this.create(...)\n  }\n}\n\n\nTo flush it on the screen, you create a React component.\n\nimport { wik, wikui, wikdom } from '@zxh19890103/wik';\n\nconst App = () =&gt; {\n  return &lt;wikdom.World defaultKeys={[\"2d\"]}&gt;\n    &lt;wikdom.Warehouse key=\"2d\" warehouse={MyWarehouse} /&gt;\n  &lt;/wikdomWorld&gt;;\n};\n\n\nThat’s all.\n",
    "url": "/quick.html"
  },
  
  {
    "title": "Introduction to React-SVGOverlay",
    "excerpt": "\n",
    "content": "概览\n\nSVGOverlay 是 leaflet 中 layer 的一种，它将 HTML 中的一个 svg 元素交给 leaflet 来管理，从而丰富了 leaflet 的展现方式，\n\nconst svg = document.querySelector('svg.robot');\nconst overlay = new L.SVGOverlay(\n  svg,\n  [\n    [0, 0],\n    [3000, 3000],\n  ],\n  {},\n);\n\n\n注意到 leaflet 并不关心 svg 里面的内容，我们可以通过对它的修改，来实现元素的动态呈现。当然，如果你的元素是静态的，SVGOverlay 就相当于ImageOverlay。\n\n修改的办法当然多种多样，可以使用直接调用 dom api，也可以使用框架比如 vue 或者 react。简单起见，我们选择了 react。\n\n因此，react-svgoverlay 的大体形式就是：\n\n\n  leaflet 负责它的位置（drag）和大小（zoom）\n  react 负责它的内容更新\n\n\n四个部分\n\n\n  ReactSVGOverlayAppServer\n  ReactSVGOverlayApp\n  SVGComponentFactory\n  ReactSVGOverlay\n\n\n它们的关系大概是这样，首先，ReactSVGOverlayAppServer 负责调用 ReactDOM 的 render 函数，渲染的根组件是 ReactSVGOverlayApp，ReactSVGOverlayApp 内部维护了一个 react 组件列表，这些 react 组件都是由 SVGComponentFactory 函数创建的。\n\n每一个 ReactSVGOverlay 都会绑定一个 react 组件，当它被添加到 map 上，这个 react 组件就会传输到 ReactSVGOverlayApp 并得以实例化。\n\n用代码示意如下，\n\n// 1. 定义一个 Svg 组件，即定义内容\nconst Svg = SVGComponentFactory(() =&gt; {\n  return &lt;path d=\"\" /&gt;;\n});\n\n// 2. 定义一个 leaflet 组件，它与上面的 react 组件绑定\nclass Overlay extends ReactSVGOverlay {\n  constructor() {\n    super(Svg);\n  }\n}\n\n// 3. 创建一个 react app，用于 svg 内容的渲染\nnew ReactSVGOverlayAppServer().boostrap(map, 'anyPane');\n// means\n// React.render(&lt;ReactSVGOverlayApp /&gt;);\n\n// 4. 实例化一个 overlay 组件，并添加到 map 上\n// add to map.\nmap.addLayer(new Overlay());\n\n// this add action leads to react re-redner for a new svg element added.\n\n\n需要给定一个层名称（pane），而且不允许后期更新，这个层名称的作用在于明确 react 渲染的节点位置。\n\n\n你声明的这个 Pane 只能用于该种方式的渲染，不要同时使用 leaflet 的 vector 渲染或者往其中放置不受管理的元素\n\n\nSVGOverlayList\n\nSVGOverlayList 封装了一些创建和绑定逻辑，让你集中精力于 react 组件和 leaflet 组件的编写。\n\nconst list = warehouse.injector.$new(SVGOverlayList);\n\nlist.add(new Overlay());\n\n\n并且，Warehouse 的 addList 则对 SVGOverlayList 创建进行了封装，因此如果你需要一个 svgoverlay 层，只需要，\n\nwarehouse.addList('robot', { renderBy: 'overlay', pane: 'robotsPane' });\n\n\n然后，尽管往 warehouse 中添加元素，\n\nwarehouse.add('robot', new RobotOverlay());\n\n\n更新 ReactOverlay 的样式和状态\n\nReactOverlay 提供了以下两个方法来更新 svg 的内容，\n\n\n  setSVGStyle\n  setSVGData\n\n",
    "url": "/guides/react-svgoverlay.html"
  },
  
  {
    "title": "Introducation to Reactive Layer",
    "excerpt": "\n",
    "content": "ReactiveLayer 是对 Leaflet 提供增强特性的 Mixin，它补充了以下功能：\n\n\n  可组成“树”\n  支持“树”的旋转、平移、缩放变换\n  基于状态的更新\n  更新合并\n\n\n使用\n\n我们提供了 ReactiveLayerMixin 这个 Mixin，在 2d/basic 和这个目录下，我们对 Leaflet 的全部 Layer 类进行了覆盖，你可以使用。如果要自己使用这个 Mixin，可以查看相关的代码，\n\nclass Circle extends mix(L.Circle).with&lt;L.Circle, ReactiveLayer&gt;(ReactiveLayerMixin) {\n  constructor(latlng: L.LatLngExpression, options?: L.CircleMarkerOptions) {\n    super(latlng, options);\n    this.position = L.latLng(latlng);\n  }\n}\n\n\n树结构及其变换\n\n相关的 API 是：addChild、removeChild、$$system、$$subSystems。\n\n\n之所以叫 system，subSystem，是因为 parent 和 children 用于其它方面；system 更贴切。\n\n\n树结构的用途在于组织复合图形，结合我们公司的业务来说，“工作站”和“输送线”就需要用复合图形表示。\n\n“工作站”由若干部分组成，每一个部分的表现形式不同，但部分始终依附于“工作站”这个整体概念。因此，当“工作站”从地图上被移除或添加，就意味着所有的“部分”也要被移除或添加。同样，工作站具备位置和角度属性，因此，你可以很方便地对“工作站”整体进行旋转和平移。\n\n为了避免重复劳动，2d/basic 目录下的 Group 组件已经帮助你实现了几乎全部的事件响应逻辑，因此如果遇到复合图形，你可以直接使用 Group。\n\nconst group = warehouse.injector.$new(Group);\n\nwarehouse.addGroup(group);\n\nconst circle = new Circle([1000, 3000]);\nconst circle1 = new Circle([3000, 1000]);\nconst circle2 = new Circle([0, 0]);\n\ngroup.addChild(circle, circle1, circle2);\n\ngroup.translate(3000, 5000);\ngroup.rotate(90);\ngroup.scales(0.618);\n\n\n视图的更新\n\n视图的更新需要借助一些 API，比如 translate、rotate，它更改了 layer 的内部状态，但没有立即调用 leaflet 的 redraw 逻辑。Wik 按照以下流程执行更新：\n\n\n  同步地修改 layer 的状态，比如 position、angle、state 等\n  使用 appendLayerRenderReq 发起一个更新请求，appendLayerRenderReq 会以 layer 为键，收集当前循环中的更新，以 EffectTag 的方式记录更新的类型和 payload\n  \n    使用 queueMicrotask 发起一个微任务，开始处理全部的请求，根据记录的 EffectTag 由条件地执行以下钩子：\n\n    \n      onRender (always)\n      onTransform\n      onTranslate\n      onRotate\n      onScale\n      onShapeUpdate\n      onLayerUpdate\n      onLayerStateUpdate\n      onInit\n    \n  \n  \n    使用 setTimeout 发起一个宏任务，调用 afterRender 钩子，有条件的 fire 三个事件：\n\n    \n      layerstate\n      position\n      angle\n    \n  \n  删除收集的更新请求\n\n\n状态变化导致的渲染\n\n你可以使用 layerState 为 layer 补充业务数据，然后通过调用 setLayerState 修改数据以更新视图。在 onRender 函数中读取 layerState 作为渲染的原因。 onLayerStateUpdate 和 afterRender 也可以用于状态渲染，但它们更有针对性，onLayerStateUpdate 最好用于 onRender 的修正，而 afterRender 最好不要涉及渲染。\n\n站在 ReactiveLayer 的角度看“渲染”二字，其含义其实就是“leaflet API 调用”。\n\n另外，我们提供的 WithLayerState 这个高阶类型，\n\nclass Dot extends Circle {\n  layerState = {\n    type: 1,\n  };\n\n  onRender() {\n    const { type } = this.layerState;\n    this.setStyle({ color: getColorByType(type) });\n  }\n}\n\ninterface Dot extends WithLayerState&lt;{ type: number }&gt; {}\n\n\nEffectTag\n\nEffectTag 用于标记本次更新请求的类型。在一次循环中，针对某一 layer 的相同类型的更新请求只会触发一次更新动作，不同的 tag 会导致对应的钩子被调用。\n\nexport enum ReactiveLayerRenderEffect {\n  /**\n   * 设置了 layer 的业务状态\n   *\n   * setLayerState\n   */\n  state = /*             */ 0b00000000000000100000000000,\n  /**\n   *\n   * 来自它端的消息，\n   *\n   * fromJSONValue\n   */\n  json2 = /*             */ 0b00000000000000010000000000,\n  /**\n   * onAdd\n   */\n  init = /*             */ 0b00000000000000001000000000,\n  /**\n   * setPosition / translates\n   */\n  translate = /*             */ 0b00000000000000000100000000,\n  /**\n   * setAngle / rotates\n   */\n  rotate = /*           */ 0b00000000000000000010000000,\n  /**\n   * setScale...\n   */\n  scale = /*            */ 0b00000000000000000001000000,\n  /**\n   * ha\n   */\n  child = /*            */ 0b00000000000000000000100000,\n  /**\n   * setLocalLatLngs / setlocalBounds\n   */\n  shape = /*            */ 0b00000000000000000000010000,\n  /**\n   * svg Or rectange bound changed\n   */\n  size = /*             */ 0b00000000000000000000001000,\n  /**\n   * fromFormValue\n   */\n  form = /*             */ 0b00000000000000000000000100,\n  /**\n   * fromJSONValue\n   */\n  json = /*             */ 0b00000000000000000000000010,\n\n  /**\n   *\n   */\n  none = /*             */ 0b00000000000000000000000000,\n}\n\n/**\n * move,rotate,scale,shape,size\n */\nexport const TRANSFORM_EFFECT =\n  ReactiveLayerRenderEffect.init |\n  ReactiveLayerRenderEffect.translate |\n  ReactiveLayerRenderEffect.rotate |\n  ReactiveLayerRenderEffect.scale |\n  ReactiveLayerRenderEffect.shape |\n  ReactiveLayerRenderEffect.size;\n\n/**\n * json,init,json2,form\n */\nexport const LAYER_DATA_UPDATE_EFFECTS =\n  ReactiveLayerRenderEffect.json |\n  ReactiveLayerRenderEffect.init |\n  ReactiveLayerRenderEffect.json2 |\n  ReactiveLayerRenderEffect.form |\n  ReactiveLayerRenderEffect.state;\n\n",
    "url": "/guides/reactive-layer.html"
  },
  
  {
    "title": "Undo & Redo",
    "excerpt": "\n",
    "content": "概览\n\n撤销与恢复功能在编辑类软件中举足轻重，它允许用户纠正错误操作以及顺应其反复变化的思想流。\n\n在软件对这个问题的实践上，我们一般会使用 command 设计模式，其思路大概是，\n\n首先，定义出全部的 command，比如 addCommand、removeCommand，每一个 command 都有“执行”和“撤销”逻辑；然后，定义一个 stack 来管理 command 实例，stack 可以 push（执行），可以 pop（撤销）。\n\ncommand 可以实现序列化逻辑，使用户端能够持久化其操作。\n\nWik 将这些命令命名为 StateAction ，类似 react 对 action 的定义，action 里执行的是系统副作用。\n\nhttps://refactoring.guru/design-patterns/command\n\nIStateAction\n\nIStateAction 声明为如下：\n\ninterface IStateAction {\n  readonly tag: number;\n  readonly isRedo: number;\n  apply(): void;\n  revert(): void;\n}\n\n\n其中 tag 是时间戳，用于删除任意历史记录，一个 Action 可以被多次执行， isRedo 表示的就是其被执行的次数。\n\nIStateActionManager\n\nIStateActionManager 的结构如下：\n\ninterface IStateActionManager {\n  push(...args: any[]): this;\n  pop(...args: any[]): this;\n  delete(tag: number): this;\n}\n\n\n实现了 IStateActionManager 类有，\n\n\n  InteractiveStateActionManager\n  StateActionManager\n\n\n其中， InteractiveStateActionManager 负责的是 layer 的交互状态管理，比如 hover 和选中以及高亮等。 StateActionManager 被用于应用级别的 undo-redo 实现。\n\n例子\n\n见 demo/redo-undo.tsx\n",
    "url": "/guides/undo-redo.html"
  },
  
  {
    "title": "Why do we need this library?",
    "excerpt": "\n",
    "content": "目前监控的图形元素均使用 leaflet 原生图形库，无业务性封装。\n\n而地图编辑器有所封装，但是所采取的 rewrite prototype 的 mixin 机制带来 2 个问题：\n\n\n  潜在的命名冲突风险\n  TS 类型声明混乱\n\n\n另外设计方面，编辑器存在的缺陷在于：\n\n\n  没有独立的业务模型\n  行为模式设计不合理\n  缺乏基于栈的图形状态管理\n\n\n而对于监控来说，业务模型与视图的响应机制纯粹基于事件，导致代码逻辑不够清晰（到处是绑定 on 和解绑 off）。\n\n当然也有可取的地方，监控的可取之处是：\n\n\n  有独立的业务模型\n\n\n编辑器的可取之处是：\n\n\n  基于 React 组件的 SVGOverlay\n  基于状态的视图更新机制\n\n\n因此，仓库图形库想要解决这些问题并采纳其中可取的地方。并且，它要封装公司的业务，以使可开箱即用，同时争取将两个端的图形部分的代码统一。\n",
    "url": "/guides/why.html"
  }
  
]

